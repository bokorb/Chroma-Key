/** * See original: http://ammmore.federicocarrara.it/?s=chroma * and : http://www.kirupa.com/forum/showthread.php?t=323425 * * Pixel Bender version: http://www.zeropointnine.com/blog/webcam-green-screen-effect-w-pixel-bender/ * and Pixel Bender tester: http://www.kynd.info/library/pixelbender/ * * How to use Pixel Bnder Filter into Flash: http://theflashblog.com/?p=386 * */import flash.display.*;import flash.filters.*;import flash.geom.*;function applyThreshold( myBitmapData:BitmapData, channel:String, op:String, threshold:uint ):BitmapData {	var maskColor:uint = (channel == "red") ? 0x00FF0000 : ( (channel == "green") ? 0x0000FF00 : 0x000000FF );	myBitmapData.threshold(myBitmapData, new Rectangle(0, 0, myBitmapData.width, myBitmapData.height), new Point(0,0), op, threshold, 0x00000000, maskColor, false );	return myBitmapData;}/** * Threshold per canale */function applyThresholdRGB( myBitmapData:BitmapData, channel:String, op:String, threshold:uint ):void {	var maskColor:uint = (channel == "red") ? 0x00FF0000 : ( (channel == "green") ? 0x0000FF00 : 0x000000FF );	myBitmapData.threshold(myBitmapData, new Rectangle(0, 0, myBitmapData.width, myBitmapData.height), new Point(0,0), op, threshold, 0x00000000, maskColor, false );}function  createBitmapMask(myBitmapData:BitmapData, colorLow:uint, colorHi:uint):void {    //red    applyThresholdRGB( myBitmapData, "red", "<", colorLow );    applyThresholdRGB( myBitmapData, "red", ">", colorHi );    //green    applyThresholdRGB( myBitmapData, "green", "<", colorLow );    applyThresholdRGB( myBitmapData, "green", ">", colorHi );    //blue    applyThresholdRGB( myBitmapData, "blue", "<", colorLow );    applyThresholdRGB( myBitmapData, "blue", ">", colorHi );}function applyChromaKey(bitMap:Bitmap, thresholdLower:uint, thresholdHigh:uint):void {	var originalBitmapData:BitmapData = bitMap.bitmapData;	var chromaBitMapData:BitmapData = originalBitmapData.clone();		chromaBitMapData.threshold(originalBitmapData, new Rectangle(0, 0, originalBitmapData.width, originalBitmapData.height), new Point(0,0), ">", thresholdLower, 0x00000000, 0x00FFFFFF, true );	chromaBitMapData.threshold(originalBitmapData, new Rectangle(0, 0, originalBitmapData.width, originalBitmapData.height), new Point(0,0), "<", thresholdHigh, 0x00000000, 0x00FFFFFF, true );		bitMap.bitmapData = chromaBitMapData;}// if keepColor = false, returns the original bitmapdata with colors between colorLow and colorHi cutted off, // otherwise (keepColor = true) return the inverse, that is the original bitmapdata with only colors from colorLow to colorHifunction chromaKey(myBitmapData:BitmapData, colorLow:uint, colorHi:uint, keepColor:Boolean = false):BitmapData {	if (keepColor) {		//throw away pixels not in my color range		//red		myBitmapData = applyThreshold( myBitmapData, "red", "<", colorLow );		myBitmapData = applyThreshold( myBitmapData, "red", ">", colorHi );		//green		myBitmapData = applyThreshold( myBitmapData, "green", "<", colorLow );		myBitmapData = applyThreshold( myBitmapData, "green", ">", colorHi );		//blue		myBitmapData = applyThreshold( myBitmapData, "blue", "<", colorLow );		myBitmapData = applyThreshold( myBitmapData, "blue", ">", colorHi );	} else {		//red		var myBitmapDataRedLow:BitmapData = applyThresholdChannel(myBitmapData,"red",">=",colorLow);		var myBitmapDataRedHigh:BitmapData = applyThresholdChannel(myBitmapData,"red","<=",colorHi);		myBitmapDataRedLow.draw(myBitmapDataRedHigh,null,null,BlendMode.MULTIPLY,null,false);		//green		var myBitmapDataGreenLow:BitmapData = applyThresholdChannel(myBitmapData,"green",">=",colorLow);		var myBitmapDataGreenHigh:BitmapData = applyThresholdChannel(myBitmapData,"green","<=",colorHi);		myBitmapDataGreenLow.draw(myBitmapDataGreenHigh,null,null,BlendMode.MULTIPLY,null,false);		//blue		var myBitmapDataBlueLow:BitmapData = applyThresholdChannel(myBitmapData,"blue",">=",colorLow);		var myBitmapDataBluenHigh:BitmapData = applyThresholdChannel(myBitmapData,"blue","<=",colorHi);		myBitmapDataBlueLow.draw(myBitmapDataBluenHigh,null,null,BlendMode.MULTIPLY,null,false);		//merge channels in output bitmapdata		chromaBitmapData = new BitmapData(myBitmapData.width, myBitmapData.height, true, 0x00000000);		chromaBitmapData.draw(myBitmapDataRedLow,null,null,BlendMode.MULTIPLY,null,false);		chromaBitmapData.draw(myBitmapDataGreenLow,null,null,BlendMode.MULTIPLY,null,false);		chromaBitmapData.draw(myBitmapDataBlueLow,null,null,BlendMode.MULTIPLY,null,false);	}	return chromaBitmapData;}/** * mantenimaneto */function applyThresholdChannel( myBitmapData:BitmapData, channel:String, op:String, color:uint ):BitmapData {		var myBitmapDataChannel:BitmapData = myBitmapData.clone();	var maskColor:uint = (channel == "red") ? 0x00FF0000 : ( (channel == "green") ? 0x0000FF00 : 0x000000FF );	myBitmapDataChannel.threshold(myBitmapData,new Rectangle(0, 0, myBitmapData.width, myBitmapData.height), new Point(0,0), op, color, 0x00000000, maskColor, false );	return myBitmapDataChannel;}